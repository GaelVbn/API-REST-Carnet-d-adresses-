const _ = {
  async: 'AsyncFunction',
  sync: 'Function'
}

/**
 * Checks if something is a promise.
 * @param {Promise?} promise The object to check.
 * @returns {boolean}
 */
function isPromise (promise)
{
  return typeof promise.then === 'function' && typeof promise.catch === 'function'
}

/**
 * Assigns callbacks to a promise.
 * @param {Promise} promise This is the promise to assign the callbacks to.
 * @param {function} resolve Like a success callback
 * @param {function} reject Like an error callback
 */
function assignPromise (promise, resolve, reject)
{
  promise.then(resolve).catch(reject)
}

/**
 * This forces this method to act as a promise.
 * @param {function} Method 
 */
const Promisify = Method =>
{
  return function ()
  {
    var args = Array.prototype.slice.call(arguments)
    
    return new Promise(async (resolve, reject) => {
      var result;
      
      try
      {
        if (Method.constructor.name === _.async)
        {
          result = await Method(...args)
        } else
        {
          result = Method(...args)
        }
        
        if (isPromise(result)) { assignPromise(result, resolve, reject) } else { resolve(result) }
        
      } catch (err)
      {
        reject(err)
      }
    })
  }
}

/**
 * This method initiates a catcher,
 * it forces all types of methods
 * to become a Promise. For
 * example; you can use:
 * * Synchronous Function
 * * Synchronous Function Promise
 * * Asynchronous Function
 * * Asynchronous Function Promise
 * This module can also be used to
 * promisify the method, if no callbacks
 * are provided, the function will
 * automatically return a promise.
 * @param {function} method This is the method to execute and catch.
 * @param {function} [onError] This method will be used as a callback whenever the method throws or reject an error.
 * @param {function} [onSuccess] This method will be used as a callback whenever the method resolves or returns
 */
function InitCatch (method, onError, onSuccess)
{
  if (typeof method !== 'function') throw new Error('Method must be a function')
  if (typeof onError !== 'function' && typeof onError !== 'undefined') throw new Error('Error callback must be a function')
  if (typeof onSuccess !== 'function' && typeof onError !== 'undefined') throw new Error('Success callback must be a function')
  
  if (!onError &&Â !onSuccess) return Promisify(method)
  
  if (!onError) onError = function () {}
  if (!onSuccess) onSuccess = function () {}
  assignPromise(Promisify(method), onSuccess, onError)
}

module.exports = InitCatch